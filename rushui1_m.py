import time

import numpy as np
from types import SimpleNamespace
import matplotlib.pyplot as plt
import copy
import pandas as pd
from scipy.interpolate import interp1d
from scipy.linalg import solve
import matplotlib
matplotlib.use('Agg')
import math

# 设置字体和解决负号问题 # 以及相关中文乱码的问题
plt.rcParams["font.sans-serif"] = ["SimHei"]  # 使用黑体
plt.rcParams["axes.unicode_minus"] = False  # 正常显示负号

class  Entry:
    def __init__(self):
        # ——————————画图参量——————————
        self.plot_pao_down_y = None
        self.plot_pao_down_x = None
        self.plot_pao_up_y = None
        self.plot_pao_up_x = None
        self.plot_zhou_y = None
        self.plot_zhou_x = None
        self.plot_dan_y = None
        self.plot_dan_x = None
        self.update_callback = None
        self.progress_callback = None
        self.min_callback_interval = 0.05
        # ——————————基本常量——————————
        self.rtd = 180 / np.pi
        self.g = 9.8
        self.rho = 1000

        # ——————————总体参数——————————
        # 定义total属性
        self.total = SimpleNamespace()
        self.total.L = 3.195   # 长度
        self.total.S = 0.0356  # 横截面积

        self.total.V = 0     # 体积
        self.total.m = 114.7   # 重量
        self.total.xc = -0.0188    # 重心坐标，体坐标系原点位于重心所在横截面中心
        self.total.yc = -0.0017
        self.total.zc = 0.0008
        self.total.Jxx = 0.63140684  # 转动惯量，按均质假设估算
        self.total.Jyy = 57.06970864
        self.total.Jzz = 57.07143674
        self.total.T = 0

        # ——————————空泡仿真参数——————————
        self.lk = 1.714  # 空化器距重心
        self.rk = 0.021  # 空化器半径
        self.dk = -0 / self.rtd  # 空化器舵角，前端面上翻为正，产生负升力和低头力矩
        self.sgm = 0  # 全局变量空化数
        self.dyc = 0  # 全局变量空泡轴线偏离值

        # ——————————泡内压力变化规律（实验数据）——————————
        pres = np.loadtxt('pres1.txt')
        self.presRec = pres[:, [0, 3]]
        # 修正初始值到95kPa
        self.presRec[:, 1] = self.presRec[:, 1] + 95 - self.presRec[0, 1]
        self.ip = 1  # 全局变量（当前空泡压力索引）

        # ——————————模型外形——————————
        self.xb = np.array([0, 0, 1.3, 2.6, 2.6, 3.1, 3.1, 2.6, 2.6, 1.3, 0, 0])
        self.yb = np.array([0, 0.021, 0.1065, 0.1065, 0.08, 0.08, -0.08, -0.08, -0.1065, -0.1065, -0.021, 0])
        self.zb = np.zeros((1, len(self.yb))).flatten()

        # ——————————入水参数——————————
        self.t0 = 0      # 仿真起始时间
        self.tend = 0.2  # 仿真终止时间
        self.tp = 0      # 全局变量：上一步仿真时间
        self.dt = 2e-4   # 仿真步长
        self.v0 = 300  # 入水速度
        self.theta0 = -10 / self.rtd  # 入水弹道角
        self.psi0 = 0 / self.rtd  # 入水偏航角
        self.phi0 = 0 / self.rtd  # 入水横滚角
        self.alpha0 = 0.03138 / self.rtd  # 入水攻角
        self.wx0 = 0 / self.rtd  # 入水横滚角速度
        self.wy0 = 0 / self.rtd  # 入水偏航角速度
        self.wz0 = 6.63 / self.rtd  # 入水俯仰角速度

        # ——————————空泡模型参数——————————
        self.A = 2  # 经验常数
        self.k1 = 4 * np.pi / self.A ** 2
        self.Dn = 2 * self.rk  # 空化器直径
        self.cx0 = 0.82  # 空化器零空化数阻力系数

        # ——————————force_rec.txt相关参数存储——————————
        self.force_data = []

        # ——————————控制参数——————————
        self.k_wz = 0.06
        self.k_theta = 0.04
        self._update_input()

    def _update_input(self):
        # 需要二次更新的参数
        self.total.D = np.sqrt(4 / np.pi * self.total.S)  # 直径
        self.xb = self.lk - self.xb  # 转到体坐标系
        # ——————————空泡数组初始化——————————
        self.nc = 200  # 空泡外形数组长度
        self.posCav = np.zeros((self.nc, 5))  # 空泡外形数组初始化
        self.cav0 = np.zeros((self.nc, 3))    # 空泡轴线数组初始化
        self.ic = 1  # 空泡记录在数组中的最后一个数据位置(索引)
        self.x0 = -self.lk * np.cos(self.theta0)
        self.y0 = -self.lk * np.sin(self.theta0)
        self.posCav[self.ic - 1, 0] = self.x0 + self.lk * np.cos(self.theta0)
        self.posCav[self.ic - 1, 1] = self.y0 + self.lk * np.sin(self.theta0)
        self.posCav[self.ic - 1, 2] = self.theta0
        self.vx0 = self.v0 * np.cos(self.alpha0)
        self.posCav[self.ic - 1, 3] = self.k1 * self.A / 4 * self.Dn * np.cos(self.dk) * self.vx0 * np.sqrt(self.cx0 * (1 + self.sgm))  # dS0
        self.posCav[self.ic - 1, 4] = np.pi * self.Dn ** 2 / 4
        self.isOpen = 1
        # ——————————空泡模型参数——————————
        self.A = 2  # 经验常数
        self.k1 = 4 * np.pi / self.A ** 2
        self.Dn = 2 * self.rk  # 空化器直径


    # 设置流体动力系数
    def _setFluid_(self, isCav, sgm):
        if isCav == 0:
            # 非空化情况
            body = np.array([
                [0.0, 0.29930654, -0.0003678, 0.00006921],
                [0.5, 0.29983629, 0.01504347, 0.00679721],
                [1.0, 0.30139431, 0.03041915, 0.0135728],
                [1.5, 0.30361569, 0.04655066, 0.02021218],
                [2.0, 0.30617984, 0.06314303, 0.02680941],
                [4.0, 0.31666579, 0.13577017, 0.05213139],
                [6.0, 0.32615016, 0.21944168, 0.07571367],
                [8.0, 0.33712794, 0.31443534, 0.09821094],
                [10.0, 0.34798534, 0.42028233, 0.11996345]
            ])

            lmd = np.array([
                [0, 0.045673052, 0.908891, 29.08451, 15.88014, 8.670559],
                [0.5, 1.045673052, 0.908891, 29.08451, 15.88014, 8.670559],
                [1, 2.045673052, 0.908891, 29.08451, 15.88014, 8.670559],
                [1.5, 3.045673052, 0.908891, 29.08451, 15.88014, 8.670559],
                [2, 4.045673052, 0.908891, 29.08451, 15.88014, 8.670559],
                [4, 5.045673052, 0.908891, 29.08451, 15.88014, 8.670559],
                [6, 6.045673052, 0.908891, 29.08451, 15.88014, 8.670559],
                [8, 7.045673052, 0.908891, 29.08451, 15.88014, 8.670559],
                [10, 8.045673052, 0.908891, 29.08451, 15.88014, 8.670559]
            ])

        else:
            # 空化情况 - 根据空化数选择
            if sgm <= 0.018:
                body = np.array([
                    [0, 0.0064866, 0.0000001, 0.0000000, -1.154835782],
                    [0.2, 0.0070330, -0.0000273, -0.0000553, -1.154835782],
                    [0.4, 0.0090264, 0.0021456, -0.0007755, -1.154835782],
                    [0.6, 0.0147004, 0.0354229, -0.0098532, -0.888715338],
                    [0.8, 0.0246238, 0.0693055, -0.0172424, -0.794879308],
                    [1, 0.0318602, 0.0862397, -0.0186621, -0.691391291],
                    [1.2, 0.0285574, 0.0901427, -0.0159515, -0.56538264],
                    [1.4, 0.0273550, 0.0872602, -0.0109434, -0.400689512],
                    [1.6, 0.0282219, 0.0866488, -0.0066705, -0.245959722],
                    [1.8, 0.0304147, 0.0921262, -0.0043397, -0.150503863],
                    [2, 0.0335547, 0.1047733, -0.0039177, -0.119468313],
                    [2.2, 0.0368605, 0.1165891, -0.0034127, -0.093521099],
                    [2.4, 0.0398658, 0.1253643, -0.0024563, -0.062600085],
                    [2.6, 0.0432105, 0.1354307, -0.0016198, -0.038213582],
                    [2.8, 0.0465494, 0.1453283, -0.0006996, -0.015380941],
                    [3, 0.0494868, 0.1537582, 0.0003691, 0.007670295]
                ])

                lmd = np.array([
                    [0, 0, 0, 0, 0, 0],
                    [0.2, 0, 0, 0, 0, 0],
                    [0.4, 0, 0, 0, 0, 0],
                    [0.6, 0.001945547, 0.05826135, 1.864363215, 1.390814958, 1.037547959],
                    [0.8, 0.008097134, 0.242476775, 7.759256792, 5.788405567, 4.318150553],
                    [1, 0.013152502, 0.393864825, 12.6036744, 9.4023411, 7.01414646],
                    [1.2, 0.005936214, 0.177765864, 5.688507662, 4.243626716, 3.16574553],
                    [1.4, 0.006194186, 0.185491094, 5.935715007, 4.428043395, 3.303320373],
                    [1.6, 0.00635188, 0.190213398, 6.086828751, 4.540774249, 3.387417589],
                    [1.8, 0.006475744, 0.19392263, 6.205524154, 4.629321019, 3.45347348],
                    [2, 0.006858025, 0.205370417, 6.571853333, 4.902602586, 3.657341529],
                    [2.2, 0.007258, 0.217348068, 6.955138176, 5.188533079, 3.870645677],
                    [2.4, 0.007658, 0.229326468, 7.338446976, 5.474481444, 4.083963157],
                    [2.6, 0.008058, 0.241304868, 7.721755776, 5.760429809, 4.297280637],
                    [2.8, 0.008458, 0.253283268, 8.105064576, 6.046378174, 4.510598118],
                    [3, 0.008858, 0.265261668, 8.488373376, 6.332326538, 4.723915598]
                ])

            elif sgm <= 0.019:
                body = np.array([
                    [0, 0.0086270, 0.0000001, 0.0000000, -0.9054136],
                    [0.2, 0.0095435, 0.0009200, -0.0003638, -0.9054136],
                    [0.4, 0.0132049, 0.0322201, -0.0091307, -0.9054136],
                    [0.6, 0.0212162, 0.0746834, -0.0186770, -0.7990144],
                    [0.8, 0.0325073, 0.0913916, -0.0204889, -0.7162798],
                    [1, 0.0355440, 0.1014105, -0.0196800, -0.6200308],
                    [1.2, 0.0323854, 0.1057335, -0.0169137, -0.5110899],
                    [1.4, 0.0310978, 0.1061294, -0.0131018, -0.3944273],
                    [1.6, 0.0318736, 0.1080314, -0.0097711, -0.2889765],
                    [1.8, 0.0340612, 0.1142207, -0.0076604, -0.2142775],
                    [2, 0.0368472, 0.1223518, -0.0061734, -0.1612081],
                    [2.2, 0.0399891, 0.1312291, -0.0049255, -0.1199196],
                    [2.4, 0.0427142, 0.1379106, -0.0035528, -0.0823086],
                    [2.6, 0.0460061, 0.1469921, -0.0024186, -0.0525701],
                    [2.8, 0.0491424, 0.1557716, -0.0012412, -0.0254582],
                    [3, 0.0521229, 0.1642847, -0.0000292, -0.0005669]
                ])

                lmd = np.array([
                    [0, 0, 0, 0, 0, 0],
                    [0.2, 0, 0, 0, 0, 0],
                    [0.4, 0.0020464, 0.061281494, 1.961007821, 1.266811052, 0.81835994],
                    [0.6, 0.0075796, 0.226978702, 7.263318451, 4.692103719, 3.031099003],
                    [0.8, 0.015241, 0.456406986, 14.60502355, 9.434845215, 6.094910009],
                    [1, 0.017439, 0.522228294, 16.71130541, 10.79550329, 6.973895128],
                    [1.2, 0.008043836, 0.240880713, 7.708182811, 4.979486096, 3.216748018],
                    [1.4, 0.008434187, 0.252570164, 8.082245245, 5.221130428, 3.372850257],
                    [1.6, 0.009210921, 0.27583024, 8.826567689, 5.701962727, 3.683467921],
                    [1.8, 0.009925941, 0.297242229, 9.511751334, 6.144591362, 3.96940602],
                    [2, 0.010934643, 0.327448819, 10.47836222, 6.769021992, 4.372788207],
                    [2.2, 0.011935, 0.35740551, 11.43697632, 7.388286703, 4.77283321],
                    [2.4, 0.012925, 0.38705205, 12.3856656, 8.001139978, 5.168736426],
                    [2.6, 0.013915, 0.41669859, 13.33435488, 8.613993252, 5.564639641],
                    [2.8, 0.013915, 0.41669859, 13.33435488, 8.613993252, 5.564639641],
                    [3, 0.013915, 0.41669859, 13.33435488, 8.613993252, 5.564639641]
                ])
            elif sgm <= 0.020:
                body = np.array([
                    [0, 0.0120036, 0.0000126, -0.0000040, -0.887695715],
                    [0.2, 0.0139380, 0.0436142, -0.0121177, -0.887695715],
                    [0.4, 0.0200968, 0.0807238, -0.0201189, -0.796295977],
                    [0.6, 0.0292715, 0.0950447, -0.0211095, -0.709613344],
                    [0.8, 0.0386546, 0.1057973, -0.0212789, -0.642607723],
                    [1, 0.0391833, 0.1129140, -0.0197656, -0.559284872],
                    [1.2, 0.0361807, 0.1175729, -0.0170966, -0.464593618],
                    [1.4, 0.0347994, 0.1198676, -0.0139404, -0.371573007],
                    [1.6, 0.0354279, 0.1229917, -0.0111073, -0.288537558],
                    [1.8, 0.0373765, 0.1285150, -0.0089718, -0.223046574],
                    [2, 0.0402012, 0.1363145, -0.0073380, -0.17199198],
                    [2.2, 0.0431344, 0.1438786, -0.0058223, -0.129290828],
                    [2.4, 0.0459803, 0.1508897, -0.0043613, -0.092348131],
                    [2.6, 0.0490293, 0.1588054, -0.0029955, -0.060265557],
                    [2.8, 0.0519529, 0.1666758, -0.0016327, -0.031297907],
                    [3, 0.0547769, 0.1745866, -0.0002890, -0.005288075]
                ])

                lmd = np.array([
                    [0, 0, 0, 0, 0, 0],
                    [0.2, 0.002038919, 0.061057468, 1.953838988, 1.262179986, 0.815368271],
                    [0.4, 0.008250455, 0.247068125, 7.906180014, 5.107392289, 3.299375419],
                    [0.6, 0.015541443, 0.465404052, 14.89292967, 9.620832565, 6.215057837],
                    [0.8, 0.021254211, 0.636478603, 20.36731528, 13.15728567, 8.499606545],
                    [1, 0.019963483, 0.597826462, 19.13044678, 12.35826862, 7.983441529],
                    [1.2, 0.012912672, 0.386682876, 12.37385202, 7.993508407, 5.163806431],
                    [1.4, 0.013415024, 0.401726309, 12.85524188, 8.304486254, 5.36469812],
                    [1.6, 0.014330686, 0.429146723, 13.73269513, 8.871321057, 5.730873403],
                    [1.8, 0.014331683, 0.429176579, 13.73365053, 8.871938244, 5.731272105],
                    [2, 0.014333739, 0.429238148, 13.73562074, 8.873210997, 5.732094304],
                    [2.2, 0.014825, 0.44394945, 14.2063824, 9.17732303, 5.928550678],
                    [2.4, 0.015625, 0.46790625, 14.973, 9.672558, 6.248472468],
                    [2.6, 0.016425, 0.49186305, 15.7396176, 10.16779297, 6.568394258],
                    [2.8, 0.017225, 0.51581985, 16.5062352, 10.66302794, 6.888316049],
                    [3, 0.018025, 0.53977665, 17.2728528, 11.15826291, 7.208237839]
                ])

            elif sgm <= 0.021:
                body = np.array([
                    [0, 0.0243732, 0.0000433, -0.0000045, -0.4318650],
                    [0.2, 0.0258971, 0.0218634, -0.0029553, -0.4318650],
                    [0.4, 0.0314730, 0.0545303, -0.0084796, -0.4968318],
                    [0.6, 0.0402960, 0.0936242, -0.0154143, -0.5260263],
                    [0.8, 0.0466153, 0.1052104, -0.0154214, -0.4683127],
                    [1, 0.0448134, 0.1144782, -0.0147260, -0.4109909],
                    [1.2, 0.0414554, 0.1222708, -0.0136843, -0.3575773],
                    [1.4, 0.0395850, 0.1294602, -0.0125949, -0.3108353],
                    [1.6, 0.0396826, 0.1365728, -0.0115560, -0.2703418],
                    [1.8, 0.0413185, 0.1425833, -0.0097220, -0.2178501],
                    [2, 0.0436639, 0.1489929, -0.0079891, -0.1713181],
                    [2.2, 0.0463918, 0.1559466, -0.0063855, -0.1308253],
                    [2.4, 0.0488608, 0.1616927, -0.0047925, -0.0946982],
                    [2.6, 0.0515441, 0.1683820, -0.0032927, -0.0624786],
                    [2.8, 0.0542892, 0.1755872, -0.0018285, -0.0332723],
                    [3, 0.0570265, 0.1833351, -0.0003969, -0.0069168]
                ])

                lmd = np.array([
                    [0, 0.011208058, 0.335636505, 10.74036816, 6.497922734, 3.931243254],
                    [0.2, 0.012525038, 0.375074788, 12.00239321, 7.261447895, 4.393175976],
                    [0.4, 0.015039862, 0.450383707, 14.41227864, 8.719428576, 5.275254289],
                    [0.6, 0.018886, 0.565560156, 18.09792499, 10.94924462, 6.624292995],
                    [0.8, 0.020232, 0.605867472, 19.3877591, 11.72959426, 7.096404526],
                    [1, 0.018237, 0.546125202, 17.47600646, 10.57298391, 6.396655266],
                    [1.2, 0.014744545, 0.441540145, 14.12928463, 8.548217199, 5.171671405],
                    [1.4, 0.012547869, 0.375758485, 12.02427152, 7.274684271, 4.401183984],
                    [1.6, 0.012692821, 0.380099218, 12.16317497, 7.358720854, 4.452026117],
                    [1.8, 0.013878541, 0.415606789, 13.29941724, 8.046147431, 4.867919196],
                    [2, 0.014477543, 0.433544503, 13.87342409, 8.393421572, 5.078020051],
                    [2.2, 0.015645207, 0.468511369, 14.9923638, 9.0703801, 5.487579961],
                    [2.4, 0.01665245, 0.498674268, 15.95757657, 9.654333823, 5.840871963],
                    [2.6, 0.017659693, 0.528837167, 16.92278933, 10.23828754, 6.194163965],
                    [2.8, 0.018666936, 0.559000065, 17.88800209, 10.82224127, 6.547455967],
                    [3, 0.019674179, 0.589162964, 18.85321486, 11.40619499, 6.900747969]
                ])

            elif sgm <= 0.022:
                body = np.array([
                    [0, 0.0346309, 0.0000336, -0.0000006, -0.007753998],
                    [0.2, 0.0369621, 0.0122254, -0.0000297, -0.007753998],
                    [0.4, 0.0420597, 0.0263295, -0.0001401, -0.017004331],
                    [0.6, 0.0509281, 0.0411018, -0.0003479, -0.027039703],
                    [0.8, 0.0538747, 0.0599916, -0.0012589, -0.067044769],
                    [1, 0.0504538, 0.0871154, -0.0043086, -0.158019723],
                    [1.2, 0.0476519, 0.1202393, -0.0085150, -0.226259914],
                    [1.4, 0.0454046, 0.1295667, -0.0078721, -0.194119779],
                    [1.6, 0.0447330, 0.1389089, -0.0076354, -0.175620333],
                    [1.8, 0.0458425, 0.1481371, -0.0071367, -0.153922431],
                    [2, 0.0475960, 0.1575861, -0.0068287, -0.138448349],
                    [2.2, 0.0498642, 0.1665373, -0.0063075, -0.121008326],
                    [2.4, 0.0521085, 0.1731722, -0.0050447, -0.093073731],
                    [2.6, 0.0547255, 0.1799753, -0.0035009, -0.062148623],
                    [2.8, 0.0573060, 0.1869534, -0.0019698, -0.033662677],
                    [3, 0.0596627, 0.1933806, -0.0004342, -0.00717295]
                ])

                lmd = np.array([
                    [0, 0.018822695, 0.563664424, 18.03726158, 9.848344824, 5.377196274],
                    [0.2, 0.020483622, 0.613402544, 19.62888142, 10.71736926, 5.851683614],
                    [0.4, 0.02257824, 0.676127975, 21.6360952, 11.81330798, 6.450066157],
                    [0.6, 0.030917651, 0.925859977, 29.62751926, 16.17662552, 8.832437531],
                    [0.8, 0.035434352, 1.061117105, 33.95574736, 18.53983806, 10.12275158],
                    [1, 0.032644816, 0.97758166, 31.28261312, 17.08030676, 9.325847492],
                    [1.2, 0.022034849, 0.659855588, 21.11537882, 11.52899684, 6.294832273],
                    [1.4, 0.015648884, 0.46862148, 14.99588737, 8.187754503, 4.470513959],
                    [1.6, 0.014053304, 0.420840242, 13.46688773, 7.352920701, 4.014694703],
                    [1.8, 0.015669761, 0.469246663, 15.01589321, 8.198677694, 4.476478021],
                    [2, 0.017310586, 0.518382808, 16.58824987, 9.057184428, 4.945222697],
                    [2.2, 0.019025, 0.56972265, 18.2311248, 9.954194141, 5.434990001],
                    [2.4, 0.020752, 0.621439392, 19.88606054, 10.85778906, 5.928352825],
                    [2.6, 0.022479, 0.673156134, 21.54099629, 11.76138397, 6.421715649],
                    [2.8, 0.024206, 0.724872876, 23.19593203, 12.66497889, 6.915078474],
                    [3, 0.025933, 0.776589618, 24.85086778, 13.56857381, 7.408441298]
                ])

            elif sgm <= 0.023:
                body = np.array([
                    [0, 0.0438250, 0.0000205, 0.0000029, 0.1725022],
                    [0.2, 0.0470332, 0.0109257, 0.0005899, 0.1725022],
                    [0.4, 0.0525684, 0.0228126, 0.0014564, 0.2039690],
                    [0.6, 0.0591106, 0.0346104, 0.0025913, 0.2392094],
                    [0.8, 0.0602795, 0.0459192, 0.0037826, 0.2631872],
                    [1, 0.0568287, 0.0575654, 0.0048963, 0.2717560],
                    [1.2, 0.0537185, 0.0702885, 0.0056526, 0.2569417],
                    [1.4, 0.0515615, 0.0878304, 0.0051768, 0.1883151],
                    [1.6, 0.0505473, 0.1246099, 0.0003680, 0.0094348],
                    [1.8, 0.0512451, 0.1478025, -0.0026114, -0.0564503],
                    [2, 0.0523496, 0.1585242, -0.0026745, -0.0539028],
                    [2.2, 0.0540703, 0.1688855, -0.0026728, -0.0505644],
                    [2.4, 0.0557887, 0.1792096, -0.0030048, -0.0535710],
                    [2.6, 0.0582801, 0.1883427, -0.0022419, -0.0380312],
                    [2.8, 0.0598193, 0.1960621, -0.0019289, -0.0314329],
                    [3, 0.0622480, 0.2032586, -0.0003858, -0.0060650]
                ])

                lmd = np.array([
                    [0, 0.02503509, 0.749700805, 23.99042576, 13.09877247, 7.151929767],
                    [0.2, 0.027365987, 0.819501847, 26.22405909, 14.31833627, 7.817811601],
                    [0.4, 0.030565611, 0.915317787, 29.29016918, 15.99243237, 8.731868077],
                    [0.6, 0.04102816, 1.228629279, 39.31613694, 21.46661077, 11.72076948],
                    [0.8, 0.042685058, 1.278246747, 40.9038959, 22.33352716, 12.19410583],
                    [1, 0.040527886, 1.213648074, 38.83673837, 21.20485915, 11.5778531],
                    [1.2, 0.027328118, 0.818367822, 26.18777029, 14.29852258, 7.806993328],
                    [1.4, 0.021036319, 0.629953609, 20.15851548, 11.00654945, 6.009576001],
                    [1.6, 0.017797752, 0.532971481, 17.0550874, 9.312077723, 5.084394437],
                    [1.8, 0.017998691, 0.538988801, 17.24764162, 9.417212326, 5.14179793],
                    [2, 0.018905938, 0.566157219, 18.11703102, 9.891898936, 5.400976819],
                    [2.2, 0.020482, 0.613353972, 19.6273271, 10.7165206, 5.851220247],
                    [2.4, 0.02196, 0.65761416, 21.04365312, 11.4898346, 6.273449694],
                    [2.6, 0.023438, 0.701874348, 22.45997914, 12.26314861, 6.69567914],
                    [2.8, 0.024916, 0.746134536, 23.87630515, 13.03646261, 7.117908587],
                    [3, 0.026394, 0.790394724, 25.29263117, 13.80977662, 7.540138033]
                ])

            else:
                # sgm > 0.023 的情况
                body = np.array([
                    [0, 0.0532393, 0.0000286, 0.0000030, 0.343186376],
                    [0.2, 0.0557941, 0.0105671, 0.0011351, 0.343186376],
                    [0.4, 0.0629577, 0.0216205, 0.0022903, 0.33844937],
                    [0.6, 0.0665592, 0.0321875, 0.0039333, 0.390427759],
                    [0.8, 0.0661440, 0.0418096, 0.0056214, 0.429573706],
                    [1, 0.0629529, 0.0516273, 0.0073257, 0.453357089],
                    [1.2, 0.0598997, 0.0617001, 0.0089002, 0.460876783],
                    [1.4, 0.0575832, 0.0727787, 0.0101737, 0.446626843],
                    [1.6, 0.0566674, 0.0851889, 0.0109386, 0.410249304],
                    [1.8, 0.0563475, 0.1028389, 0.0103344, 0.321068251],
                    [2, 0.0570239, 0.1327563, 0.0070749, 0.17026797],
                    [2.2, 0.0588349, 0.1682796, 0.0016592, 0.031501996],
                    [2.4, 0.0600533, 0.1799832, 0.0010495, 0.018630013],
                    [2.6, 0.0618048, 0.1905049, 0.0010023, 0.016810133],
                    [2.8, 0.0636224, 0.2006724, 0.0010707, 0.017046964],
                    [3, 0.0650128, 0.2110274, 0.0005134, 0.007772684]
                ])

                lmd = np.array([
                    [0, 0.031237665, 0.935443116, 29.93417971, 16.34406212, 8.92385792],
                    [0.2, 0.032598578, 0.976197017, 31.23830454, 17.05611428, 9.312638395],
                    [0.4, 0.044095715, 1.320490281, 42.255689, 23.0716062, 12.59709698],
                    [0.6, 0.045240424, 1.354769737, 43.35263159, 23.67053685, 12.92411312],
                    [0.8, 0.045673052, 1.367725215, 43.76720689, 23.89689496, 13.04770465],
                    [1, 0.043691579, 1.308388025, 41.86841679, 22.86015557, 12.48164494],
                    [1.2, 0.03430854, 1.027403539, 32.87691324, 17.95079463, 9.801133868],
                    [1.4, 0.02426402, 0.726610343, 23.25153097, 12.69533591, 6.931653408],
                    [1.6, 0.024396021, 0.730563245, 23.37802384, 12.76440101, 6.969362954],
                    [1.8, 0.024076942, 0.721008105, 23.07225936, 12.59745361, 6.878209673],
                    [2, 0.023686325, 0.709310688, 22.69794203, 12.39307635, 6.766619686],
                    [2.2, 0.025687, 0.769222902, 24.61513286, 13.43986254, 7.338164949],
                    [2.4, 0.026853, 0.804139938, 25.73247802, 14.049933, 7.671263416],
                    [2.6, 0.028019, 0.839056974, 26.84982317, 14.66000345, 8.004361884],
                    [2.8, 0.029185,	0.87397401,	27.96716832,  15.2700739,  8.337460351],
                    [3,	0.030351, 0.908891046, 29.08451347,	15.88014436,   8.670558818]
                ])

            # 继续添加其他空化数情况...
            # 由于篇幅限制，这里只展示前两种情况
            # 实际使用时需要将文档中所有情况都添加完整
        return body, lmd

        # 准备仿真初始条件
    def _init_sim_condition_(self):
        # 模型初始速度分量
        self.vx0 = self.v0 * np.cos(self.alpha0)
        self.vy0 = -self.v0 * np.sin(self.alpha0)
        self.vz0 = 0

        # 模型初始位置：从空化器触水开始仿真
        self.x0 = -self.lk * np.cos(self.theta0)
        self.y0 = -self.lk * np.sin(self.theta0)
        self.z0 = 0

        y1 = np.array([[self.vx0], [self.vy0], [self.vz0], [self.wx0], [self.wy0], [self.wz0], [self.theta0], [self.psi0], [self.phi0], [self.x0], [self.y0], [self.z0]])

        return y1

    def interp1(self, x, y, xi):
        f = interp1d(x, y, kind='linear', fill_value='extrapolate')
        a = f(xi)
        return float(a)

    def _equation_solving_(self):
        t = 0
        y = self._init_sim_condition_()
        T = t
        Y = y
        Alpha = self.alpha0
        Sgm = self.sgm
        isCav = 1
        pc = 101325
        QC = 0
        dQC = 0
        QCp = 0
        Apc = np.array([pc])
        current_time = time.time()
        last_callback_time = time.time()
        while t < self.tend:
            # print(t)

            # 根据当前状态求导函数
            vx = y[0, 0]
            vy = y[1, 0]
            vz = y[2, 0]

            wx = y[3, 0]
            wy = y[4, 0]
            wz = y[5, 0]

            theta = y[6, 0]
            psi = y[7, 0]
            phi = y[8, 0]

            x0 = y[9, 0]
            y0 = y[10, 0]
            z0 = y[11, 0]

            # 求当前合速度、攻角等
            v = np.sqrt(vx ** 2 + vy ** 2 + vz ** 2)
            alpha = np.arctan(-vy / vx)
            beta = np.arctan(vz / np.sqrt(vx ** 2 + vy ** 2))

            # 求转换矩阵：由弹体转换为地面系
            st = np.sin(theta)
            ct = np.cos(theta)
            sp = np.sin(psi)
            cp = np.cos(psi)
            sf = np.sin(phi)
            cf = np.cos(phi)

            Cb0 = np.array([
                [cp * ct, sp * sf - cp * st * cf, sp * cf + cp * st * sf],
                [st, ct * cf, -ct * sf],
                [-sp * ct, cp * sf + sp * st * cf, cp * cf - sp * st * sf]
            ])
            Cb0 = Cb0.reshape(3, 3)

            # 取总体参数 , S, V, m, xc, yc, zc, Jxx, Jyy, Jzz, T1
            L = self.total.L
            S = self.total.S
            V = self.total.V
            m = self.total.m
            xc = self.total.xc
            yc = self.total.yc
            zc = self.total.zc
            Jxx = self.total.Jxx
            Jyy = self.total.Jyy
            Jzz = self.total.Jzz
            T1 = self.total.T

            LB = 0.755  # 弹身长，不含尾喷管

            ## 计算流体动力
            # 动压系数计算
            q1 = 0.5 * self.rho * S * v ** 2
            q2 = q1 * L
            q3 = 0.5 * self.rho * S * v * L
            q4 = q3 * L
            Sk = np.pi * self.rk ** 2

            ## 加入控制
            self.dk = self.k_wz * wz + self.k_theta * theta * self.rtd
            ## 舵角限幅
            self.dk = math.copysign(min(abs(self.dk), 20/self.rtd), self.dk)

            # 空化器水动力计算
            vxn = vx
            vyn = vy + wz * self.lk

            alphak = -np.arctan(vyn / vxn)

            vk = np.sqrt(vxn ** 2 + vyn ** 2)
            # 空化器前端面法向速度
            vkn = vxn * np.cos(self.dk) + vyn * np.sin(self.dk)

            # 垂直于空化器前端面的法向力
            Fkn = 0.5 * self.rho * Sk * vkn**2 * self.cx0 * (1 + self.sgm)

            # 空化器水动力转体轴系
            Xk = -Fkn * np.cos(self.dk)
            Yk = -Fkn * np.sin(self.dk)
            Mzk = Yk * self.lk

            # 获取空化器在地面系坐标
            dlk = Cb0 @ np.array([[self.lk], [0], [0]])
            xn = x0 + dlk[0, 0]
            yn = y0 + dlk[1, 0]

            # 更新空泡形态
            # 空泡闭合位置
            lt = 0

            # 提取当前压力
            while self.presRec[self.ip - 1, 0] < t:
                self.ip += 1

            # 空泡切片半径更新
            for i in range(1, self.ic + 1):  # ic为空泡数组已有数据最大索引
                # 更新空泡半径
                self.posCav[i - 1, 4] = self.posCav[i - 1, 4] + self.posCav[i - 1, 3] * self.dt
                # 更新空泡半径扩张率
                p8 = 101325 - self.rho * self.g * self.posCav[i - 1, 1]  # 切片所在深度水压力
                # 泡内压力，由实验数据给出
                # 压力修正系数：0.75
                kpc = 1
                pc1 = self.presRec[self.ip - 1, 1] * 1e3 * kpc
                dp = p8 - pc1
                self.sgm = dp / (0.5 * self.rho * vk ** 2)
                if self.posCav[i - 1, 4] > 0:
                    # 如果空泡尚未闭合，计算空泡截面扩张率
                    self.posCav[i - 1, 3] = self.posCav[i - 1, 3] - self.k1 * dp / self.rho * self.dt
                else:
                    # 空泡截面已闭合，退出循环，不再更新
                    self.posCav[i - 1, 4] = 0
                    self.posCav[i - 1, 3] = 0

            # 数组元素依次后移一位
            for i in range(self.ic + 1, 1, -1):  # 从 ic+1 递减到 2
                self.posCav[i - 1, :] = self.posCav[i - 2, :]  # 注意：Python 索引从 0 开始

            # 在数组首位插入当前空化器中心位置、空泡面积增长率和初始面积（空化器面积）
            Dk = self.Dn * np.cos(self.dk + alphak)
            ds0 = self.k1 * self.A / 4 * Dk * vk * np.sqrt(self.cx0 * (1 + self.sgm))
            s0 = np.pi * Dk ** 2 / 4
            self.posCav[0, :] = np.array([xn, yn, theta + alphak, ds0, s0]).flatten()

            if self.ic < self.nc - 1:
                self.ic += 1

            self.tp = t

            # 保存空泡轴线到文件
            with open('cavity.txt', 'a') as fid:
                fid.write(f'{t:5.3f}{self.posCav[0, 0]:8.3f}{self.posCav[0, 1]:8.3f}\n')

            # 将空泡轴线坐标转化为雷体坐标系下
            cav = np.zeros((self.nc, 3))
            self.cav0 = cav.copy()
            cav1 = cav.copy()
            cav2 = cav.copy()
            QC = 0
            dQC = 0
            for j in range(1, self.ic + 1):
                # 空化器轨迹
                self.cav0[j - 1, 0] = self.posCav[j - 1, 0]
                self.cav0[j - 1, 1] = self.posCav[j - 1, 1]
                self.cav0[j - 1, 2] = 0

                # 空泡半径
                rcj = np.sqrt(self.posCav[j - 1, 4] / np.pi)

                # 空泡上轮廓
                cav1[j - 1, 0] = self.posCav[j - 1, 0] + rcj * np.cos(self.posCav[j - 1, 2] + np.pi / 2)
                cav1[j - 1, 1] = self.posCav[j - 1, 1] + rcj * np.sin(self.posCav[j - 1, 2] + np.pi / 2)
                cav1[j - 1, 2] = 0

                # 空泡下轮廓
                cav2[j - 1, 0] = self.posCav[j - 1, 0] - rcj * np.cos(self.posCav[j - 1, 2] + np.pi / 2)
                cav2[j - 1, 1] = self.posCav[j - 1, 1] - rcj * np.sin(self.posCav[j - 1, 2] + np.pi / 2)
                cav2[j - 1, 2] = 0

                # 计算开口空泡容积
                if self.isOpen:
                    if j < self.ic + 1:
                        QC += np.pi * rcj ** 2 * np.sqrt((self.posCav[j - 1, 0] - self.posCav[j, 0]) ** 2 + (self.posCav[j - 1, 1] - self.posCav[j, 1]) ** 2)
                        dQC += self.posCav[j - 1, 3] * np.sqrt((self.posCav[j - 1, 0] - self.posCav[j, 0]) ** 2 + (self.posCav[j - 1, 1] - self.posCav[j, 1]) ** 2)

            dQC = (QC - QCp) / self.dt
            QCp = QC

            # 空泡轴线转弹体坐标系
            for i in range(1, self.ic + 1):
                cav[i - 1, 0] = self.cav0[i - 1, 0] - x0
                reuitg0 = cav[i - 1, 0]
                cav[i - 1, 1] = self.cav0[i - 1, 1] - y0
                reuitg1 = cav[i - 1, 1]

                cav[i - 1, :][0] = reuitg0
                cav[i - 1, :][1] = reuitg1

                fsdgfk = np.array([reuitg0, reuitg1, cav[i - 1, 2]])

                cav[i - 1, :] = fsdgfk @ Cb0

            # 开口面积

            if self.isOpen:
                # 空泡截面面积
                So = self.posCav[self.ic - 1, 4]
                # 航行体截面面积
                rb = self.interp1(self.xb[1: 4], self.yb[1: 4], cav[0, 0])
                Sb = np.pi * rb ** 2
                c = 1.1890e-005

                if QC == 0:
                    dpc = 0
                else:
                    dpc = (pc * (So - Sb) * np.sqrt(2 * (101325 - pc) / (c * pc)) - pc * dQC) / QC
            # 判断开口空泡阶段
            if cav[self.ic - 1, 0] > 0:
                self.isOpen = 1
            else:
                self.isOpen = 0

            # 查询空泡闭合位置
            j = 2
            while j < self.nc:
                # 计算空泡切片半径
                rcj = np.sqrt(self.posCav[j - 1, 4] / np.pi)
                # 插值求模型半径
                rb = self.interp1(self.xb[1: 4], self.yb[1: 4], cav[j - 1, 0])

                if cav[j - 1, 0] < self.lk - LB:
                    rb = 0

                # 如果空泡截面小于航行体半径，空泡开始闭合
                if rcj < rb:
                    lt = cav[j - 1, 0]  # 闭合轴向位置
                    self.dyc = cav[j - 1, 1]  # 闭合时空轴线偏离值
                    break
                else:
                    # 如果空泡直径大于航行器，且空泡轴线偏离值超过两者半径差，说明空泡开始闭合
                    if np.abs(cav[j - 1, 1]) > rcj - rb:
                        lt = cav[j - 1, 0]  # 闭合轴向位置
                        self.dyc = cav[j - 1, 1]  # 闭合时空泡轴线偏离值
                        break
                    else:
                        if cav[j - 1, 0] < self.lk - LB:
                            lt = self.lk - LB  # 闭合轴向位置
                            # 闭合式空泡轴线偏离值
                            # !!!!zheli
                            self.dyc = self.interp1(cav[(j - 1 - 1):j, 0], cav[(j - 1 - 1):j, 1], lt)
                            break

                        j += 1

                        if j == self.ic:
                            lt = cav[j - 1, 0]  # 水面轴向位置
                            self.dyc = cav[j - 1, 1]  # 水面空泡轴线偏离值
                            break

            # 刷新空泡外形
            posb = Cb0 @ np.vstack([self.xb.T, self.yb.T, self.zb.T])   #np.array([[self.xb], [self.yb], [self.zb]])
            posc = Cb0 @ np.array([[lt], [0], [0]])

            # --------画图----------
            # 准备绘图数据
            self.plot_dan_x = posb[0, :]
            self.plot_dan_y = posb[1, :]

            self.plot_zhou_x = self.cav0[:, 0] - x0
            self.plot_zhou_y = self.cav0[:, 1] - y0
            self.plot_pao_up_x = cav1[:, 0] - x0
            self.plot_pao_up_y = cav1[:, 1] - y0
            self.plot_pao_down_x = cav2[:, 0] - x0
            self.plot_pao_down_y = cav2[:, 1] - y0

            # 计算航行器总冲角，暂时按纵平面考虑
            alphat = -np.arctan(vy / vx) * self.rtd

            # 根据闭合位置计算攻角
            alphay = np.arctan(self.dyc / (self.lk - lt)) * self.rtd

            # 全沾湿流体动力
            body, lmd = self._setFluid_(isCav, self.sgm)
            cxb = np.sign(1) * interp1d(body[:, 0], body[:, 1], fill_value='extrapolate')(np.abs(alphay))
            cyb = np.sign(alphay) * interp1d(body[:, 0], body[:, 2], fill_value='extrapolate')(np.abs(alphay))
            mzb = np.sign(alphay) * interp1d(body[:, 0], body[:, 3], fill_value='extrapolate')(np.abs(alphay))

            kk = 1.0
            Xb = -cxb * q1 * kk
            Yb = cyb * q1 * kk * 0.3
            Mzb = mzb * q2 * kk * 0.3

            if self.isOpen == 1:
                Yb = 0
                Mzb = 0

            Mxb = 0
            Zb = 0
            Myb = 0

            # 将这一行数据存入列表（可以是元组或列表）
            self.force_data.append([t, self.sgm, alphat, Xb, Yb, Zb, Myb, Mzb])
            # with open('force_rec.txt', 'a') as fid:
            #     fid.write(f'{t:8.4f} {self.sgm:8.6f} {alphat:8.6f} {Xb:8.6f} {Yb:8.6f} {Zb:8.6f} {Myb:8.6f} {Mzb:8.6f}\n')

            # 鳍舵总的位置力和阻尼力
            Xw = 0
            Yw = 0
            Zw = 0
            Myw = 0
            Mzw = 0
            Mxw = 0

            if isCav == 0:
                # 全沾湿
                Cya = body[2, 2] / body[2, 0] * self.rtd
                Cyw = 0.4 * Cya
                Yw = q3 * Cyw * wz
                mzw = -0.2 * Cya
                Mzw = q4 * mzw * wz

            # 考虑尾拍力
            # 准备滑行力计算公式参数
            rbe = 0.213 / 2
            # 从圆柱段开始查询尾部开始沾湿的点
            k = 2
            while k < cav.shape[0] and cav[k, 0] > 0.366:
                k += 1
            k_1 = k

            # 获取 cav 的行数
            n_rows = cav.shape[0]

            # 循环，注意 Python 的 range 是左闭右开区间
            for k in range(k_1 - 1, n_rows):  # 将 MATLAB 索引转为 Python 索引
                # 计算平方根内的值
                left_value = rbe + np.sqrt(cav[k, 1] ** 2 + cav[k, 2] ** 2)
                right_value = np.sqrt(self.posCav[k, 4] / np.pi)

                # 判断条件
                if left_value < right_value:
                    # 条件成立，继续循环
                    continue
                else:
                    # 条件不成立，跳出循环
                    break

            k_py = k - 1  # 转换为Python索引

            # 检查条件：if(cav(k,1)>-0.964 && cav(k,1)~= 0)
            if cav[k_py, 0] > -0.964 and cav[k_py, 0] != 0:  # 如果尾部沾湿,沾湿点在尾端面之前
                # 计算尾部壁面轴向沾湿长度
                lbw = abs(-0.964 - cav[k_py, 0])

                # 沾湿起始点的空泡中心坐标（雷体系）
                r1y0 = cav[k_py, 1]
                r1z0 = cav[k_py, 2]

                # 计算角度 thetas0
                if r1y0 == 0 and r1z0 == 0:
                    thetas0 = 0
                else:
                    thetas0 = math.atan(abs(r1z0 / r1y0))

                # 查询尾端面处的空泡中心坐标以及空泡半径
                # 寻找第一个不满足 cav(j,1) > -0.964 的行
                j = 1  # Python索引，对应MATLAB的j=2
                n_rows = cav.shape[0]

                while j < n_rows and cav[j, 0] > -0.964:
                    j += 1

                # 注意：循环结束后，j是第一个不满足条件的行索引
                # 但根据MATLAB原代码注释，我们需要的是满足条件的最后一行
                # 所以需要调整
                if j > 1 and cav[j - 1, 0] > -0.964:
                    j_final = j - 1
                else:
                    j_final = 1  # 如果没有找到满足条件的行，使用第一行


                # 尾端面空泡半径
                rke = math.sqrt(self.posCav[k_py, 4] / math.pi)

                # 尾端面空泡中心坐标（雷体系）
                r1ye = cav[j_final, 1]
                r1ze = cav[j_final, 2]

                # 计算角度 thetase
                if r1ye == 0 and r1ze == 0:
                    thetase = 0
                else:
                    thetase = math.atan(abs(r1ze / r1ye))

                # 计算壳体尾端面处的径向沾湿长度
                he = abs(rbe + math.sqrt(r1ye ** 2 + r1ze ** 2) - rke)

                # 计算e
                e = abs(rke - rbe)

                # 计算航行体的滑行角
                if lbw != 0:
                    alphaw = math.atan(he / lbw)
                else:
                    alphaw = 0

                # 计算自由液面滑行阻力系数
                if vx * lbw != 0:
                    Cxf = 0.031 / (vx * lbw / 1.05372) ** (1 / 7)
                else:
                    Cxf = 0

                # 计算uc和us
                if e != 0:
                    uc = math.sqrt(he / e)
                else:
                    uc = 0

                if rbe != 0:
                    us = 2 * math.sqrt(e * he) / rbe
                else:
                    us = 0

                # 计算Fn
                if v != 0 and rbe + 2 * he != 0 and rbe + he != 0:
                    Fn = -math.pi * self.rho * rke ** 2 * v ** 2 * math.sin(alphaw) * math.cos(alphaw) * (rbe + he) / (
                                rbe + 2 * he) * (1 - (e / (e + he)) ** 2)
                else:
                    Fn = 0

                # 初始化Fxf
                Fxf = 0
                # 原注释中的复杂公式，这里暂时不计算

                # 计算thetasp
                thetasp = 0.25 * (thetas0 + 3 * thetase)

                # 计算力和力矩
                if r1ye != 0:
                    Yb1_sign = np.sign(r1ye)
                else:
                    Yb1_sign = 0

                if r1ze != 0:
                    Zb1_sign = np.sign(r1ze)
                else:
                    Zb1_sign = 0

                Xb1 = Fxf
                Yb1 = -Fn * math.cos(thetasp) * Yb1_sign
                Zb1 = -Fn * math.sin(thetasp) * Zb1_sign

                Mxb1 = -rbe * (Zb1 * math.cos(thetasp) + Yb1 * math.sin(thetasp))
                Myb1 = Xb1 * rbe * math.sin(thetasp) - Zb1 * (1 / 3 * lbw - 2.678 + 1.714)
                Mzb1 = Xb1 * rbe * math.cos(thetasp) + Yb1 * (1 / 3 * lbw - 2.678 + 1.714)
            else:  # 如果尾部不沾湿
                Xb1 = 0
                Yb1 = 0
                Zb1 = 0
                Mxb1 = 0
                Myb1 = 0
                Mzb1 = 0

            Xb = Xb + Xb1
            Yb = Yb + Yb1
            Zb = Zb + Zb1
            Mxb = Mxb + Mxb1
            Myb = Myb + Myb1
            Mzb = Mzb + Mzb1

            # 浮力和重力
            Vb = interp1d(lmd[:, 0], lmd[:, 1], fill_value='extrapolate')(np.abs(alphay))
            Vb = Vb * (60 / 213) ** 3

            if isCav == 1:
                lb = interp1d(body[:, 0], body[:, 4], fill_value='extrapolate')(np.abs(alphay))
            else:
                lb = self.lk - 0.437

            # debug：忽略浮力
            B = self.rho * Vb * self.g
            G = m * self.g
            DG = np.array([0, B - G, 0]) @ Cb0
            MG = np.cross(np.array([xc, yc, zc]), np.array([0, -G, 0]) @ Cb0)
            MG[2] = B * lb * 0.9 / 3.195

            # 一定攻角范围内附加质量置0
            n11 = 0
            n22 = 0
            n26 = 0
            n66 = 0

            if self.isOpen == 0:
                scale3 = (60 / 213) ** 3
                scale4 = (60 / 213) ** 4
                scale5 = (60 / 213) ** 5

                n11 = interp1d(lmd[:, 0], lmd[:, 2], fill_value='extrapolate')(np.abs(alphay)) * scale3
                n22 = interp1d(lmd[:, 0], lmd[:, 3], fill_value='extrapolate')(np.abs(alphay)) * scale3
                n26 = interp1d(lmd[:, 0], lmd[:, 4], fill_value='extrapolate')(np.abs(alphay)) * scale4
                n66 = interp1d(lmd[:, 0], lmd[:, 5], fill_value='extrapolate')(np.abs(alphay)) * scale5

            n33 = n22
            n55 = n66
            n35 = -n26
            n44 = 0

            # 惯性矩阵
            Amn = np.array([
                [m + n11, 0, 0, 0, m * zc, -m * yc],
                [0, m + n22, 0, -m * zc, 0, m * xc + n26],
                [0, 0, m + n33, m * yc, -m * xc + n35, 0],
                [0, -m * zc, m * yc, Jxx + n44, 0, 0],
                [m * zc, 0, -m * xc + n35, 0, Jyy + n55, 0],
                [-m * yc, m * xc + n26, 0, 0, 0, Jzz + n66]
            ])

            DAmn = np.array([
                [0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0]
            ])

            Am = np.array([
                [m, 0, 0, 0, m * zc, -m * yc],
                [0, m, 0, -m * zc, 0, m * xc],
                [0, 0, m, m * yc, -m * xc, 0],
                [0, -m * zc, m * yc, Jxx, 0, 0],
                [m * zc, 0, -m * xc, 0, Jyy, 0],
                [-m * yc, m * xc, 0, 0, 0, Jzz]
            ])

            # 角速度矩阵
            Avw = np.array([
                [0, -wz, wy, 0, 0, 0],
                [wz, 0, -wx, 0, 0, 0],
                [-wy, wx, 0, 0, 0, 0],
                [0, -vz, vy, 0, -wz, wy],
                [vz, 0, -vx, wz, 0, -wx],
                [-vy, vx, 0, -wy, wx, 0]
            ])

            XT = T1
            Zk = 0
            Mxk = 0
            Myk = 0

            # 全沾湿时空化器阻力不另计算
            if isCav == 0:
                Xk = 0

            AFM = np.array([
                Xk + Xb + Xw + DG[0] + XT,
                Yk + Yb + Yw + DG[1],
                Zk + Zb + Zw + DG[2],
                Mxk + Mxb + Mxw + MG[0],
                Myk + Myb + Myw + MG[1],
                Mzk + Mzb + Mzw + MG[2]
            ])  # 坐标原点建立在浮心，所以只有重力矩没有浮力矩

            # 初始化导数向量
            dydt = np.zeros(12)

            # 1. 线速度和角速度导数 (前6个状态)
            y_6 = np.transpose(y[0:6])  # 提取前6个状态变量

            # 解线性方程组: Amn * dydt[0:6] = (-Avw * Am * y_6 + AFM - DAmn * y_6)
            # 等价于 MATLAB 的 Amn \ (-Avw * Am * y_6 + AFM - DAmn * y_6)
            rhs = -Avw @ Am @ y_6.T + AFM[:, np.newaxis] - DAmn @ y_6.T
            dydt[0:6] = np.dot(np.linalg.inv(Amn), rhs).T
            # dydt[:6] = solve(Amn, -Avw * (Am @ y[0, :6]) + AFM - DAmn @ y[0, :6])
            dydt[2:5] = 0  # debug 关闭水平面弹道
            dydt[6] = wy * sf + wz * cf
            dydt[7] = (wy * cf - wz * sf) / ct
            dydt[8] = wx - dydt[7] * st
            dydt[9:12] = (Cb0 @ y[0:3]).T

            # 更新状态向量
            t += self.dt
            y = y.copy() + (dydt.T * self.dt)[:, np.newaxis]
            pc += dpc * self.dt

            T = np.vstack([T, t])
            Y = np.hstack([Y, y])
            Alpha = np.vstack([Alpha, alphay])
            Sgm = np.vstack([Sgm, self.sgm])
            Apc = np.vstack([Apc, pc])

            # if t > 0.0112:
            #     sgfakjhfs = 0


            # 绘制Apc关于t的曲线//估计是压力曲线
            current_time = time.time()

            if hasattr(self, 'update_callback') and current_time - last_callback_time > self.min_callback_interval:
                last_callback_time = current_time
                # ========== 进度回调 ==========
                if self.progress_callback:
                    self.progress_callback(int(t / self.dt), int(self.tend / self.dt))

                # ========== 实时数据准备 ==========
                if self.update_callback:
                    # 准备实时数据

                    data = {
                        'motions': {
                            't': t,
                            'alphat': alphat,
                            'y': y
                        },
                        'points': {
                            'plot_dan_x': self.plot_dan_x,
                            'plot_dan_y': self.plot_dan_y,
                            'plot_zhou_x': self.plot_zhou_x,
                            'plot_zhou_y': self.plot_zhou_y,
                            'plot_pao_up_x': self.plot_pao_up_x,
                            'plot_pao_up_y': self.plot_pao_up_y,
                            'plot_pao_down_x': self.plot_pao_down_x,
                            'plot_pao_down_y': self.plot_pao_down_y
                        },
                        'forces': {
                            'AFM': AFM
                        },
                        'datas': {
                            'ts': T,
                            'ys': Y

                        }
                    }
                    # 调用回调函数
                    self.update_callback(data)


        t = T
        y = Y.T

        return y, t

    def _plot_results(self):
        # 获取弹道参数y和时间t
        y, t = self._equation_solving_()

        # print("开始写入self.force_data...")
        # pd.DataFrame(self.force_data).to_excel('self_force_data.xlsx', index=False, header=False)
        # print("self.force_data写完咯...")

        # 弹道参数预处理
        y[:, 3:9] = y[:, 3:9] * self.rtd
        # pd.DataFrame(y).to_excel('entry_y.xlsx', index=False, header=False)
        vx = y[:, 0]
        vy = y[:, 1]
        vz = y[:, 2]
        v = np.sqrt(vx ** 2 + vy ** 2 + vz ** 2)
        alpha = -np.arctan(vy / vx) * self.rtd
        alpha = alpha[:, np.newaxis]
        beta = np.arctan(vz / np.sqrt(vx ** 2 + vy ** 2)) * self.rtd
        # pd.DataFrame(alpha).to_excel('alpha.xlsx', index=False, header=False)
        # pd.DataFrame(t).to_excel('t.xlsx', index=False, header=False)

        # print("开始画图...")

        # 攻角曲线
        plt.figure(1, figsize=(10, 6))
        plt.plot(t, alpha, 'k-', linewidth=2)
        plt.grid(True)
        plt.xlabel('t(s)')
        plt.ylabel('$\\alpha$(°)')
        plt.savefig('alpha-t.png')
        #plt.show()

        # 速度曲线
        plt.figure(2, figsize=(10, 6))
        plt.plot(t, v, 'k-', linewidth=2)
        plt.grid(True)
        plt.xlabel('t(s)')
        plt.ylabel('v(m/s)')
        plt.savefig('v-t.png')
        #plt.show()


        # 纵平面弹道
        plt.figure(3, figsize=(10, 6))
        plt.plot(y[:, 9], y[:, 10], 'k-', linewidth=2)
        plt.grid(True)
        plt.xlabel('x(m)')
        plt.ylabel('y(m/s)')
        plt.savefig('y-x.png')
        #plt.show()

        # wz
        plt.figure(4, figsize=(10, 6))
        plt.plot(t, y[:, 5], 'k-', linewidth=2)
        plt.grid(True)
        plt.xlabel('t(s)')
        plt.ylabel('$\\omega_z$(°/s)')
        plt.savefig('wz-t.png')
        # plt.show()

        # theta
        plt.figure(5, figsize=(10, 6))
        plt.plot(t, y[:, 6], 'k-', linewidth=2)
        plt.grid(True)
        plt.xlabel('t(s)')
        plt.ylabel('$\\theta$(°)')
        plt.savefig('theta-t.png')
        # plt.show()

        # 读取 force_rec.txt 文件（假设是空格或制表符分隔的数值数据）
        # force = np.loadtxt('force_rec.txt')
        # pd.DataFrame(force).to_excel('force.xlsx', index=False, header=False)

        # 原变量self.force_data是list类型，是为了能够append，但是这里画图的操作是对array操作，所以需要转换一下
        self.force_data = np.array(self.force_data)

        # 创建一个包含3个子图的画布
        fig, axs = plt.subplots(3, 1, figsize=(10, 8), sharex=True)

        # 子图1: 攻角曲线 (alpha vs t) + 应力放大100倍
        axs[0].plot(self.force_data[:, 0], self.force_data[:, 2], label=r'$\alpha$')  # alpha 列
        axs[0].plot(self.force_data[:, 0], self.force_data[:, 1] * 100, label=r'$\sigma_m \times 100$')  # 应力列 ×100
        axs[0].grid(True)
        axs[0].set_title('攻角曲线')
        axs[0].set_xlabel('t/s')
        axs[0].set_ylabel(r'$\alpha / ^\circ$')
        axs[0].legend()

        # 子图2: 轴向力/法向力曲线 (Fx/Fy vs t)
        axs[1].plot(self.force_data[:, 0], self.force_data[:, 3:5])  # 第5、6列（索引从0开始：第4、5列）
        axs[1].grid(True)
        axs[1].set_title('轴向力/法向力曲线')
        axs[1].set_xlabel('t/s')
        axs[1].set_ylabel('Fx/Fy/N')

        # 子图3: 俯仰力矩曲线 (Mz vs t)
        axs[2].plot(self.force_data[:, 0], self.force_data[:, 7])  # 第8列（索引7）
        axs[2].grid(True)
        axs[2].set_title('俯仰力矩曲线')
        axs[2].set_xlabel('t/s')
        axs[2].set_ylabel('Mz/Nm')

        # 自动调整布局，避免重叠
        plt.tight_layout()
        plt.savefig('force_curves.png', dpi=300, bbox_inches='tight')
        #plt.show()

        # print("画图结束...")


    def get_results(self):

        # print("开始入水弹道仿真。。。")
        self._update_input()
        # 获取弹道参数y和时间t
        y, t = self._equation_solving_()

        # print("开始写入self.force_data...")
        # pd.DataFrame(self.force_data).to_excel('self_force_data.xlsx', index=False, header=False)
        # print("self.force_data写完咯...")

        # 弹道参数预处理
        y[:, 3:9] = y[:, 3:9] * self.rtd
        # pd.DataFrame(y).to_excel('entry_y.xlsx', index=False, header=False)
        vx = y[:, 0]
        vy = y[:, 1]
        vz = y[:, 2]
        v = np.sqrt(vx ** 2 + vy ** 2 + vz ** 2)
        alpha = -np.arctan(vy / vx) * self.rtd
        alpha = alpha[:, np.newaxis]
        beta = np.arctan(vz / np.sqrt(vx ** 2 + vy ** 2)) * self.rtd
        self.y = y
        self.t = t

        # print("入水弹道仿真完成")

        return t, y

if __name__ == "__main__":
    entry = Entry()

    # 计算
    # entry._equation_solving_()

    # 画图
    # entry._plot_results()

